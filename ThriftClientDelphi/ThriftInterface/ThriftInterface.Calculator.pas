(**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *)

unit ThriftInterface.Calculator;

interface

uses
  Classes,
  SysUtils,
  Generics.Collections,
  Thrift,
  Thrift.Utils,
  Thrift.Collections,
  Thrift.Protocol,
  Thrift.Transport,
  ThriftInterface.Common;

const
  cThriftInterface_Calculator_Option_AnsiStr_Binary = False;
  cThriftInterface_Calculator_Option_Register_Types = False;
  cThriftInterface_Calculator_Option_ConstPrefix    = False;
  cThriftInterface_Calculator_Option_Events         = False;
  cThriftInterface_Calculator_Option_XmlDoc         = False;

type
  TCalculatorService = class
  public
    type
      Iface = interface
        function add(param1: Integer; param2: Integer): Integer;
        function sub(param1: Integer; param2: Integer): Integer;
        function mul(param1: Integer; param2: Integer): Integer;
        function div_(param1: Integer; param2: Integer): Integer;
      end;

      TClient = class( TInterfacedObject, Iface)
      public
        constructor Create( prot: IProtocol); overload;
        constructor Create( const iprot: IProtocol; const oprot: IProtocol); overload;
      protected
        iprot_: IProtocol;
        oprot_: IProtocol;
        seqid_: Integer;
      public
        property InputProtocol: IProtocol read iprot_;
        property OutputProtocol: IProtocol read oprot_;
      protected
        // Iface
        function add(param1: Integer; param2: Integer): Integer;
        function sub(param1: Integer; param2: Integer): Integer;
        function mul(param1: Integer; param2: Integer): Integer;
        function div_(param1: Integer; param2: Integer): Integer;
      public
        procedure send_add(param1: Integer; param2: Integer);
        function recv_add(): Integer;
        procedure send_sub(param1: Integer; param2: Integer);
        function recv_sub(): Integer;
        procedure send_mul(param1: Integer; param2: Integer);
        function recv_mul(): Integer;
        procedure send_div(param1: Integer; param2: Integer);
        function recv_div(): Integer;
      end;

      TProcessorImpl = class( TInterfacedObject, IProcessor)
      public
        constructor Create( iface_: Iface );
        destructor Destroy; override;
      private
        iface_: Iface;
      protected
        type
          TProcessFunction = reference to procedure( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol);
      protected
        processMap_: IThriftDictionary<string, TProcessFunction>;
      public
        function Process( const iprot: IProtocol; const oprot: IProtocol; const events : IProcessorEvents): Boolean;
        procedure add_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol);
        procedure sub_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol);
        procedure mul_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol);
        procedure div_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol);
      end;

      IAdd_args = interface(IBase)
        function GetParam1: Integer;
        procedure SetParam1( const Value: Integer);
        function GetParam2: Integer;
        procedure SetParam2( const Value: Integer);

        property Param1: Integer read GetParam1 write SetParam1;
        property Param2: Integer read GetParam2 write SetParam2;

        function Get__isset_Param1: Boolean;
        function Get__isset_Param2: Boolean;

        property __isset_Param1: Boolean read Get__isset_Param1;
        property __isset_Param2: Boolean read Get__isset_Param2;
      end;

      TAdd_argsImpl = class(TInterfacedObject, IBase, IAdd_args)
      private
        FParam1: Integer;
        FParam2: Integer;
        
        F__isset_Param1: Boolean;
        F__isset_Param2: Boolean;
        
        function GetParam1: Integer;
        procedure SetParam1( const Value: Integer);
        function GetParam2: Integer;
        procedure SetParam2( const Value: Integer);

        function Get__isset_Param1: Boolean;
        function Get__isset_Param2: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; override;

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Param1: Integer read GetParam1 write SetParam1;
        property Param2: Integer read GetParam2 write SetParam2;

        // isset
        property __isset_Param1: Boolean read Get__isset_Param1;
        property __isset_Param2: Boolean read Get__isset_Param2;
      end;

      IAdd_result = interface(IBase)
        function GetSuccess: Integer;
        procedure SetSuccess( const Value: Integer);

        property Success: Integer read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TAdd_resultImpl = class(TInterfacedObject, IBase, IAdd_result)
      private
        FSuccess: Integer;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: Integer;
        procedure SetSuccess( const Value: Integer);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; override;

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: Integer read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      ISub_args = interface(IBase)
        function GetParam1: Integer;
        procedure SetParam1( const Value: Integer);
        function GetParam2: Integer;
        procedure SetParam2( const Value: Integer);

        property Param1: Integer read GetParam1 write SetParam1;
        property Param2: Integer read GetParam2 write SetParam2;

        function Get__isset_Param1: Boolean;
        function Get__isset_Param2: Boolean;

        property __isset_Param1: Boolean read Get__isset_Param1;
        property __isset_Param2: Boolean read Get__isset_Param2;
      end;

      TSub_argsImpl = class(TInterfacedObject, IBase, ISub_args)
      private
        FParam1: Integer;
        FParam2: Integer;
        
        F__isset_Param1: Boolean;
        F__isset_Param2: Boolean;
        
        function GetParam1: Integer;
        procedure SetParam1( const Value: Integer);
        function GetParam2: Integer;
        procedure SetParam2( const Value: Integer);

        function Get__isset_Param1: Boolean;
        function Get__isset_Param2: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; override;

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Param1: Integer read GetParam1 write SetParam1;
        property Param2: Integer read GetParam2 write SetParam2;

        // isset
        property __isset_Param1: Boolean read Get__isset_Param1;
        property __isset_Param2: Boolean read Get__isset_Param2;
      end;

      ISub_result = interface(IBase)
        function GetSuccess: Integer;
        procedure SetSuccess( const Value: Integer);

        property Success: Integer read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TSub_resultImpl = class(TInterfacedObject, IBase, ISub_result)
      private
        FSuccess: Integer;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: Integer;
        procedure SetSuccess( const Value: Integer);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; override;

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: Integer read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      IMul_args = interface(IBase)
        function GetParam1: Integer;
        procedure SetParam1( const Value: Integer);
        function GetParam2: Integer;
        procedure SetParam2( const Value: Integer);

        property Param1: Integer read GetParam1 write SetParam1;
        property Param2: Integer read GetParam2 write SetParam2;

        function Get__isset_Param1: Boolean;
        function Get__isset_Param2: Boolean;

        property __isset_Param1: Boolean read Get__isset_Param1;
        property __isset_Param2: Boolean read Get__isset_Param2;
      end;

      TMul_argsImpl = class(TInterfacedObject, IBase, IMul_args)
      private
        FParam1: Integer;
        FParam2: Integer;
        
        F__isset_Param1: Boolean;
        F__isset_Param2: Boolean;
        
        function GetParam1: Integer;
        procedure SetParam1( const Value: Integer);
        function GetParam2: Integer;
        procedure SetParam2( const Value: Integer);

        function Get__isset_Param1: Boolean;
        function Get__isset_Param2: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; override;

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Param1: Integer read GetParam1 write SetParam1;
        property Param2: Integer read GetParam2 write SetParam2;

        // isset
        property __isset_Param1: Boolean read Get__isset_Param1;
        property __isset_Param2: Boolean read Get__isset_Param2;
      end;

      IMul_result = interface(IBase)
        function GetSuccess: Integer;
        procedure SetSuccess( const Value: Integer);

        property Success: Integer read GetSuccess write SetSuccess;

        function Get__isset_Success: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
      end;

      TMul_resultImpl = class(TInterfacedObject, IBase, IMul_result)
      private
        FSuccess: Integer;
        
        F__isset_Success: Boolean;
        
        function GetSuccess: Integer;
        procedure SetSuccess( const Value: Integer);

        function Get__isset_Success: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; override;

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: Integer read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
      end;

      IDiv_args = interface(IBase)
        function GetParam1: Integer;
        procedure SetParam1( const Value: Integer);
        function GetParam2: Integer;
        procedure SetParam2( const Value: Integer);

        property Param1: Integer read GetParam1 write SetParam1;
        property Param2: Integer read GetParam2 write SetParam2;

        function Get__isset_Param1: Boolean;
        function Get__isset_Param2: Boolean;

        property __isset_Param1: Boolean read Get__isset_Param1;
        property __isset_Param2: Boolean read Get__isset_Param2;
      end;

      TDiv_argsImpl = class(TInterfacedObject, IBase, IDiv_args)
      private
        FParam1: Integer;
        FParam2: Integer;
        
        F__isset_Param1: Boolean;
        F__isset_Param2: Boolean;
        
        function GetParam1: Integer;
        procedure SetParam1( const Value: Integer);
        function GetParam2: Integer;
        procedure SetParam2( const Value: Integer);

        function Get__isset_Param1: Boolean;
        function Get__isset_Param2: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; override;

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Param1: Integer read GetParam1 write SetParam1;
        property Param2: Integer read GetParam2 write SetParam2;

        // isset
        property __isset_Param1: Boolean read Get__isset_Param1;
        property __isset_Param2: Boolean read Get__isset_Param2;
      end;

      IDiv_result = interface(IBase)
        function GetSuccess: Integer;
        procedure SetSuccess( const Value: Integer);
        function GetError: TTInvalidParameterException.ITInvalidParameterExceptionFactory;
        procedure SetError( const Value: TTInvalidParameterException.ITInvalidParameterExceptionFactory);

        property Success: Integer read GetSuccess write SetSuccess;
        property Error: TTInvalidParameterException.ITInvalidParameterExceptionFactory read GetError write SetError;

        function Get__isset_Success: Boolean;
        function Get__isset_Error: Boolean;

        property __isset_Success: Boolean read Get__isset_Success;
        property __isset_Error: Boolean read Get__isset_Error;
      end;

      TDiv_resultImpl = class(TInterfacedObject, IBase, IDiv_result)
      private
        FSuccess: Integer;
        FError: TTInvalidParameterException.ITInvalidParameterExceptionFactory;
        
        F__isset_Success: Boolean;
        F__isset_Error: Boolean;
        
        function GetSuccess: Integer;
        procedure SetSuccess( const Value: Integer);
        function GetError: TTInvalidParameterException.ITInvalidParameterExceptionFactory;
        procedure SetError( const Value: TTInvalidParameterException.ITInvalidParameterExceptionFactory);

        function Get__isset_Success: Boolean;
        function Get__isset_Error: Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; override;

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: Integer read GetSuccess write SetSuccess;
        property Error: TTInvalidParameterException.ITInvalidParameterExceptionFactory read GetError write SetError;

        // isset
        property __isset_Success: Boolean read Get__isset_Success;
        property __isset_Error: Boolean read Get__isset_Error;
      end;

  end;
  
implementation

constructor TCalculatorService.TClient.Create( prot: IProtocol);
begin
  Create( prot, prot );
end;

constructor TCalculatorService.TClient.Create( const iprot: IProtocol; const oprot: IProtocol);
begin
  inherited Create;
  iprot_ := iprot;
  oprot_ := oprot;
end;

function TCalculatorService.TClient.add(param1: Integer; param2: Integer): Integer;
begin
  send_add(param1, param2);
  Result := recv_add();
end;

procedure TCalculatorService.TClient.send_add(param1: Integer; param2: Integer);
var
  _args0 : IAdd_args;
  _msg1 : Thrift.Protocol.TThriftMessage;
begin
  seqid_ := seqid_ + 1;
  Thrift.Protocol.Init( _msg1, 'add', TMessageType.Call, seqid_);
  oprot_.WriteMessageBegin( _msg1 );
  _args0 := TAdd_argsImpl.Create();
  _args0.Param1 := param1;
  _args0.Param2 := param2;
  _args0.Write(oprot_);
  _args0.Param1 := 0;
  _args0.Param2 := 0;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TCalculatorService.TClient.recv_add(): Integer;
var
  _msg1 : Thrift.Protocol.TThriftMessage;
  _ax3 : TApplicationException;
  _ret4 : IAdd_result;
begin
  _msg1 := iprot_.ReadMessageBegin();
  if (_msg1.Type_ = TMessageType.Exception) then
  begin
    _ax3 := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise _ax3;
  end;
  _ret4 := TAdd_resultImpl.Create();
  _ret4.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (_ret4.__isset_success) then
  begin
    Result := _ret4.Success;
    Exit;
  end;
  raise TApplicationExceptionMissingResult.Create('add failed: unknown result');
end;

function TCalculatorService.TClient.sub(param1: Integer; param2: Integer): Integer;
begin
  send_sub(param1, param2);
  Result := recv_sub();
end;

procedure TCalculatorService.TClient.send_sub(param1: Integer; param2: Integer);
var
  _args5 : ISub_args;
  _msg6 : Thrift.Protocol.TThriftMessage;
begin
  seqid_ := seqid_ + 1;
  Thrift.Protocol.Init( _msg6, 'sub', TMessageType.Call, seqid_);
  oprot_.WriteMessageBegin( _msg6 );
  _args5 := TSub_argsImpl.Create();
  _args5.Param1 := param1;
  _args5.Param2 := param2;
  _args5.Write(oprot_);
  _args5.Param1 := 0;
  _args5.Param2 := 0;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TCalculatorService.TClient.recv_sub(): Integer;
var
  _msg6 : Thrift.Protocol.TThriftMessage;
  _ax8 : TApplicationException;
  _ret9 : ISub_result;
begin
  _msg6 := iprot_.ReadMessageBegin();
  if (_msg6.Type_ = TMessageType.Exception) then
  begin
    _ax8 := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise _ax8;
  end;
  _ret9 := TSub_resultImpl.Create();
  _ret9.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (_ret9.__isset_success) then
  begin
    Result := _ret9.Success;
    Exit;
  end;
  raise TApplicationExceptionMissingResult.Create('sub failed: unknown result');
end;

function TCalculatorService.TClient.mul(param1: Integer; param2: Integer): Integer;
begin
  send_mul(param1, param2);
  Result := recv_mul();
end;

procedure TCalculatorService.TClient.send_mul(param1: Integer; param2: Integer);
var
  _args10 : IMul_args;
  _msg11 : Thrift.Protocol.TThriftMessage;
begin
  seqid_ := seqid_ + 1;
  Thrift.Protocol.Init( _msg11, 'mul', TMessageType.Call, seqid_);
  oprot_.WriteMessageBegin( _msg11 );
  _args10 := TMul_argsImpl.Create();
  _args10.Param1 := param1;
  _args10.Param2 := param2;
  _args10.Write(oprot_);
  _args10.Param1 := 0;
  _args10.Param2 := 0;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TCalculatorService.TClient.recv_mul(): Integer;
var
  _msg11 : Thrift.Protocol.TThriftMessage;
  _ax13 : TApplicationException;
  _ret14 : IMul_result;
begin
  _msg11 := iprot_.ReadMessageBegin();
  if (_msg11.Type_ = TMessageType.Exception) then
  begin
    _ax13 := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise _ax13;
  end;
  _ret14 := TMul_resultImpl.Create();
  _ret14.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (_ret14.__isset_success) then
  begin
    Result := _ret14.Success;
    Exit;
  end;
  raise TApplicationExceptionMissingResult.Create('mul failed: unknown result');
end;

function TCalculatorService.TClient.div_(param1: Integer; param2: Integer): Integer;
begin
  send_div(param1, param2);
  Result := recv_div();
end;

procedure TCalculatorService.TClient.send_div(param1: Integer; param2: Integer);
var
  _args15 : IDiv_args;
  _msg16 : Thrift.Protocol.TThriftMessage;
begin
  seqid_ := seqid_ + 1;
  Thrift.Protocol.Init( _msg16, 'div', TMessageType.Call, seqid_);
  oprot_.WriteMessageBegin( _msg16 );
  _args15 := TDiv_argsImpl.Create();
  _args15.Param1 := param1;
  _args15.Param2 := param2;
  _args15.Write(oprot_);
  _args15.Param1 := 0;
  _args15.Param2 := 0;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TCalculatorService.TClient.recv_div(): Integer;
var
  _msg16 : Thrift.Protocol.TThriftMessage;
  _ex17 : Exception;
  _ax18 : TApplicationException;
  _ret19 : IDiv_result;
begin
  _msg16 := iprot_.ReadMessageBegin();
  if (_msg16.Type_ = TMessageType.Exception) then
  begin
    _ax18 := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise _ax18;
  end;
  _ret19 := TDiv_resultImpl.Create();
  _ret19.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (_ret19.__isset_success) then
  begin
    Result := _ret19.Success;
    Exit;
  end;
  if (_ret19.__isset_Error) then
  begin
    _ex17 := _ret19.Error.CreateException;
    raise _ex17;
  end;
  raise TApplicationExceptionMissingResult.Create('div failed: unknown result');
end;

constructor TCalculatorService.TProcessorImpl.Create( iface_: Iface );
begin
  inherited Create;
  Self.iface_ := iface_;
  processMap_ := TThriftDictionaryImpl<string, TProcessFunction>.Create;
  processMap_.AddOrSetValue( 'add', add_Process);
  processMap_.AddOrSetValue( 'sub', sub_Process);
  processMap_.AddOrSetValue( 'mul', mul_Process);
  processMap_.AddOrSetValue( 'div', div_Process);
end;

destructor TCalculatorService.TProcessorImpl.Destroy;
begin
  inherited;
end;

function TCalculatorService.TProcessorImpl.Process( const iprot: IProtocol; const oprot: IProtocol; const events : IProcessorEvents): Boolean;
var
  msg : Thrift.Protocol.TThriftMessage;
  fn : TProcessFunction;
  x : TApplicationException;
begin
  try
    msg := iprot.ReadMessageBegin();
    fn := nil;
    if not processMap_.TryGetValue(msg.Name, fn)
    or not Assigned(fn) then
    begin
      TProtocolUtil.Skip(iprot, TType.Struct);
      iprot.ReadMessageEnd();
      x := TApplicationExceptionUnknownMethod.Create('Invalid method name: ''' + msg.Name + '''');
      Thrift.Protocol.Init( msg, msg.Name, TMessageType.Exception, msg.SeqID);
      oprot.WriteMessageBegin( msg);
      x.Write(oprot);
      oprot.WriteMessageEnd();
      oprot.Transport.Flush();
      Result := True;
      Exit;
    end;
    fn(msg.SeqID, iprot, oprot);
  except
    on TTransportExceptionTimedOut do begin
      Result := True;
      Exit;
    end;
    else begin
      Result := False;
      Exit;
    end;
  end;
  Result := True;
end;

// both way processor
procedure TCalculatorService.TProcessorImpl.add_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol);
var
  args: IAdd_args;
  msg: Thrift.Protocol.TThriftMessage;
  ret: IAdd_result;
  appx : TApplicationException;
begin
  args := TAdd_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TAdd_resultImpl.Create;
  try
    ret.Success := iface_.add(args.Param1, args.Param2);
    args.Param1 := 0;
    args.Param2 := 0;
  except
    on E: Exception do begin
      appx := TApplicationExceptionInternalError.Create(E.Message);
      try
        Thrift.Protocol.Init( msg, 'add', TMessageType.Exception, seqid);
        oprot.WriteMessageBegin( msg);
        appx.Write(oprot);
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
        Exit;
      finally
        appx.Free;
      end;
    end;
  end;
  Thrift.Protocol.Init( msg, 'add', TMessageType.Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TCalculatorService.TProcessorImpl.sub_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol);
var
  args: ISub_args;
  msg: Thrift.Protocol.TThriftMessage;
  ret: ISub_result;
  appx : TApplicationException;
begin
  args := TSub_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TSub_resultImpl.Create;
  try
    ret.Success := iface_.sub(args.Param1, args.Param2);
    args.Param1 := 0;
    args.Param2 := 0;
  except
    on E: Exception do begin
      appx := TApplicationExceptionInternalError.Create(E.Message);
      try
        Thrift.Protocol.Init( msg, 'sub', TMessageType.Exception, seqid);
        oprot.WriteMessageBegin( msg);
        appx.Write(oprot);
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
        Exit;
      finally
        appx.Free;
      end;
    end;
  end;
  Thrift.Protocol.Init( msg, 'sub', TMessageType.Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TCalculatorService.TProcessorImpl.mul_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol);
var
  args: IMul_args;
  msg: Thrift.Protocol.TThriftMessage;
  ret: IMul_result;
  appx : TApplicationException;
begin
  args := TMul_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TMul_resultImpl.Create;
  try
    ret.Success := iface_.mul(args.Param1, args.Param2);
    args.Param1 := 0;
    args.Param2 := 0;
  except
    on E: Exception do begin
      appx := TApplicationExceptionInternalError.Create(E.Message);
      try
        Thrift.Protocol.Init( msg, 'mul', TMessageType.Exception, seqid);
        oprot.WriteMessageBegin( msg);
        appx.Write(oprot);
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
        Exit;
      finally
        appx.Free;
      end;
    end;
  end;
  Thrift.Protocol.Init( msg, 'mul', TMessageType.Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TCalculatorService.TProcessorImpl.div_Process( seqid: Integer; const iprot: IProtocol; const oprot: IProtocol);
var
  args: IDiv_args;
  msg: Thrift.Protocol.TThriftMessage;
  ret: IDiv_result;
  appx : TApplicationException;
begin
  args := TDiv_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TDiv_resultImpl.Create;
  try
    ret.Success := iface_.div_(args.Param1, args.Param2);
    args.Param1 := 0;
    args.Param2 := 0;
  except
    on E: TTInvalidParameterException do begin
      ret.Error := E.TInvalidParameterExceptionFactory;
    end;
    on E: Exception do begin
      appx := TApplicationExceptionInternalError.Create(E.Message);
      try
        Thrift.Protocol.Init( msg, 'div', TMessageType.Exception, seqid);
        oprot.WriteMessageBegin( msg);
        appx.Write(oprot);
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
        Exit;
      finally
        appx.Free;
      end;
    end;
  end;
  Thrift.Protocol.Init( msg, 'div', TMessageType.Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

constructor TCalculatorService.TAdd_argsImpl.Create;
begin
  inherited;
end;

destructor TCalculatorService.TAdd_argsImpl.Destroy;
begin
  inherited;
end;

function TCalculatorService.TAdd_argsImpl.GetParam1: Integer;
begin
  Result := FParam1;
end;

procedure TCalculatorService.TAdd_argsImpl.SetParam1( const Value: Integer);
begin
  F__isset_Param1 := True;
  FParam1 := Value;
end;

function TCalculatorService.TAdd_argsImpl.Get__isset_Param1: Boolean;
begin
  Result := F__isset_Param1;
end;

function TCalculatorService.TAdd_argsImpl.GetParam2: Integer;
begin
  Result := FParam2;
end;

procedure TCalculatorService.TAdd_argsImpl.SetParam2( const Value: Integer);
begin
  F__isset_Param2 := True;
  FParam2 := Value;
end;

function TCalculatorService.TAdd_argsImpl.Get__isset_Param2: Boolean;
begin
  Result := F__isset_Param2;
end;

procedure TCalculatorService.TAdd_argsImpl.Read( const iprot: IProtocol);
var
  field_ : TThriftField;
  struc : TThriftStruct;
  tracker : IProtocolRecursionTracker;

begin
  tracker := iprot.NextRecursionLevel;
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = TType.Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = TType.I32) then begin
            Self.Param1 := iprot.ReadI32();
          end else begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = TType.I32) then begin
            Self.Param2 := iprot.ReadI32();
          end else begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TCalculatorService.TAdd_argsImpl.Write( const oprot: IProtocol);
var
  struc : TThriftStruct;
  field_ : TThriftField;
  tracker : IProtocolRecursionTracker;
begin
  tracker := oprot.NextRecursionLevel;
  Thrift.Protocol.Init( struc, 'add_args');
  oprot.WriteStructBegin(struc);
  Thrift.Protocol.Init( field_);
  if (__isset_Param1) then begin
    field_.Name := 'param1';
    field_.Type_  := TType.I32;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Self.Param1);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Param2) then begin
    field_.Name := 'param2';
    field_.Type_  := TType.I32;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Self.Param2);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TCalculatorService.TAdd_argsImpl.ToString: string;
var
  _sb20 : TThriftStringBuilder;
  _first21 : Boolean;
begin
  _sb20 := TThriftStringBuilder.Create('(');
  try
    _first21 := TRUE;
    if (__isset_Param1) then begin
      if not _first21 then _sb20.Append(',');
      _first21 := FALSE;
      _sb20.Append('Param1: ');
      _sb20.Append( Self.Param1);
    end;
    if (__isset_Param2) then begin
      if not _first21 then _sb20.Append(',');
      _first21 := FALSE;
      _sb20.Append('Param2: ');
      _sb20.Append( Self.Param2);
    end;
    _sb20.Append(')');
    Result := _sb20.ToString;
    if _first21 then {prevent warning};
  finally
    _sb20.Free;
  end;
end;

constructor TCalculatorService.TAdd_resultImpl.Create;
begin
  inherited;
end;

destructor TCalculatorService.TAdd_resultImpl.Destroy;
begin
  inherited;
end;

function TCalculatorService.TAdd_resultImpl.GetSuccess: Integer;
begin
  Result := FSuccess;
end;

procedure TCalculatorService.TAdd_resultImpl.SetSuccess( const Value: Integer);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TCalculatorService.TAdd_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TCalculatorService.TAdd_resultImpl.Read( const iprot: IProtocol);
var
  field_ : TThriftField;
  struc : TThriftStruct;
  tracker : IProtocolRecursionTracker;

begin
  tracker := iprot.NextRecursionLevel;
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = TType.Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = TType.I32) then begin
            Self.Success := iprot.ReadI32();
          end else begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TCalculatorService.TAdd_resultImpl.Write( const oprot: IProtocol);
var
  struc : TThriftStruct;
  field_ : TThriftField;
  tracker : IProtocolRecursionTracker;
begin
  tracker := oprot.NextRecursionLevel;
  Thrift.Protocol.Init( struc, 'add_result');
  oprot.WriteStructBegin(struc);
  Thrift.Protocol.Init( field_);
  if (__isset_Success) then begin
    field_.Name := 'Success';
    field_.Type_  := TType.I32;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Self.Success);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TCalculatorService.TAdd_resultImpl.ToString: string;
var
  _sb22 : TThriftStringBuilder;
  _first23 : Boolean;
begin
  _sb22 := TThriftStringBuilder.Create('(');
  try
    _first23 := TRUE;
    if (__isset_Success) then begin
      if not _first23 then _sb22.Append(',');
      _first23 := FALSE;
      _sb22.Append('Success: ');
      _sb22.Append( Self.Success);
    end;
    _sb22.Append(')');
    Result := _sb22.ToString;
    if _first23 then {prevent warning};
  finally
    _sb22.Free;
  end;
end;

constructor TCalculatorService.TSub_argsImpl.Create;
begin
  inherited;
end;

destructor TCalculatorService.TSub_argsImpl.Destroy;
begin
  inherited;
end;

function TCalculatorService.TSub_argsImpl.GetParam1: Integer;
begin
  Result := FParam1;
end;

procedure TCalculatorService.TSub_argsImpl.SetParam1( const Value: Integer);
begin
  F__isset_Param1 := True;
  FParam1 := Value;
end;

function TCalculatorService.TSub_argsImpl.Get__isset_Param1: Boolean;
begin
  Result := F__isset_Param1;
end;

function TCalculatorService.TSub_argsImpl.GetParam2: Integer;
begin
  Result := FParam2;
end;

procedure TCalculatorService.TSub_argsImpl.SetParam2( const Value: Integer);
begin
  F__isset_Param2 := True;
  FParam2 := Value;
end;

function TCalculatorService.TSub_argsImpl.Get__isset_Param2: Boolean;
begin
  Result := F__isset_Param2;
end;

procedure TCalculatorService.TSub_argsImpl.Read( const iprot: IProtocol);
var
  field_ : TThriftField;
  struc : TThriftStruct;
  tracker : IProtocolRecursionTracker;

begin
  tracker := iprot.NextRecursionLevel;
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = TType.Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = TType.I32) then begin
            Self.Param1 := iprot.ReadI32();
          end else begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = TType.I32) then begin
            Self.Param2 := iprot.ReadI32();
          end else begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TCalculatorService.TSub_argsImpl.Write( const oprot: IProtocol);
var
  struc : TThriftStruct;
  field_ : TThriftField;
  tracker : IProtocolRecursionTracker;
begin
  tracker := oprot.NextRecursionLevel;
  Thrift.Protocol.Init( struc, 'sub_args');
  oprot.WriteStructBegin(struc);
  Thrift.Protocol.Init( field_);
  if (__isset_Param1) then begin
    field_.Name := 'param1';
    field_.Type_  := TType.I32;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Self.Param1);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Param2) then begin
    field_.Name := 'param2';
    field_.Type_  := TType.I32;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Self.Param2);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TCalculatorService.TSub_argsImpl.ToString: string;
var
  _sb24 : TThriftStringBuilder;
  _first25 : Boolean;
begin
  _sb24 := TThriftStringBuilder.Create('(');
  try
    _first25 := TRUE;
    if (__isset_Param1) then begin
      if not _first25 then _sb24.Append(',');
      _first25 := FALSE;
      _sb24.Append('Param1: ');
      _sb24.Append( Self.Param1);
    end;
    if (__isset_Param2) then begin
      if not _first25 then _sb24.Append(',');
      _first25 := FALSE;
      _sb24.Append('Param2: ');
      _sb24.Append( Self.Param2);
    end;
    _sb24.Append(')');
    Result := _sb24.ToString;
    if _first25 then {prevent warning};
  finally
    _sb24.Free;
  end;
end;

constructor TCalculatorService.TSub_resultImpl.Create;
begin
  inherited;
end;

destructor TCalculatorService.TSub_resultImpl.Destroy;
begin
  inherited;
end;

function TCalculatorService.TSub_resultImpl.GetSuccess: Integer;
begin
  Result := FSuccess;
end;

procedure TCalculatorService.TSub_resultImpl.SetSuccess( const Value: Integer);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TCalculatorService.TSub_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TCalculatorService.TSub_resultImpl.Read( const iprot: IProtocol);
var
  field_ : TThriftField;
  struc : TThriftStruct;
  tracker : IProtocolRecursionTracker;

begin
  tracker := iprot.NextRecursionLevel;
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = TType.Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = TType.I32) then begin
            Self.Success := iprot.ReadI32();
          end else begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TCalculatorService.TSub_resultImpl.Write( const oprot: IProtocol);
var
  struc : TThriftStruct;
  field_ : TThriftField;
  tracker : IProtocolRecursionTracker;
begin
  tracker := oprot.NextRecursionLevel;
  Thrift.Protocol.Init( struc, 'sub_result');
  oprot.WriteStructBegin(struc);
  Thrift.Protocol.Init( field_);
  if (__isset_Success) then begin
    field_.Name := 'Success';
    field_.Type_  := TType.I32;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Self.Success);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TCalculatorService.TSub_resultImpl.ToString: string;
var
  _sb26 : TThriftStringBuilder;
  _first27 : Boolean;
begin
  _sb26 := TThriftStringBuilder.Create('(');
  try
    _first27 := TRUE;
    if (__isset_Success) then begin
      if not _first27 then _sb26.Append(',');
      _first27 := FALSE;
      _sb26.Append('Success: ');
      _sb26.Append( Self.Success);
    end;
    _sb26.Append(')');
    Result := _sb26.ToString;
    if _first27 then {prevent warning};
  finally
    _sb26.Free;
  end;
end;

constructor TCalculatorService.TMul_argsImpl.Create;
begin
  inherited;
end;

destructor TCalculatorService.TMul_argsImpl.Destroy;
begin
  inherited;
end;

function TCalculatorService.TMul_argsImpl.GetParam1: Integer;
begin
  Result := FParam1;
end;

procedure TCalculatorService.TMul_argsImpl.SetParam1( const Value: Integer);
begin
  F__isset_Param1 := True;
  FParam1 := Value;
end;

function TCalculatorService.TMul_argsImpl.Get__isset_Param1: Boolean;
begin
  Result := F__isset_Param1;
end;

function TCalculatorService.TMul_argsImpl.GetParam2: Integer;
begin
  Result := FParam2;
end;

procedure TCalculatorService.TMul_argsImpl.SetParam2( const Value: Integer);
begin
  F__isset_Param2 := True;
  FParam2 := Value;
end;

function TCalculatorService.TMul_argsImpl.Get__isset_Param2: Boolean;
begin
  Result := F__isset_Param2;
end;

procedure TCalculatorService.TMul_argsImpl.Read( const iprot: IProtocol);
var
  field_ : TThriftField;
  struc : TThriftStruct;
  tracker : IProtocolRecursionTracker;

begin
  tracker := iprot.NextRecursionLevel;
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = TType.Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = TType.I32) then begin
            Self.Param1 := iprot.ReadI32();
          end else begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = TType.I32) then begin
            Self.Param2 := iprot.ReadI32();
          end else begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TCalculatorService.TMul_argsImpl.Write( const oprot: IProtocol);
var
  struc : TThriftStruct;
  field_ : TThriftField;
  tracker : IProtocolRecursionTracker;
begin
  tracker := oprot.NextRecursionLevel;
  Thrift.Protocol.Init( struc, 'mul_args');
  oprot.WriteStructBegin(struc);
  Thrift.Protocol.Init( field_);
  if (__isset_Param1) then begin
    field_.Name := 'param1';
    field_.Type_  := TType.I32;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Self.Param1);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Param2) then begin
    field_.Name := 'param2';
    field_.Type_  := TType.I32;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Self.Param2);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TCalculatorService.TMul_argsImpl.ToString: string;
var
  _sb28 : TThriftStringBuilder;
  _first29 : Boolean;
begin
  _sb28 := TThriftStringBuilder.Create('(');
  try
    _first29 := TRUE;
    if (__isset_Param1) then begin
      if not _first29 then _sb28.Append(',');
      _first29 := FALSE;
      _sb28.Append('Param1: ');
      _sb28.Append( Self.Param1);
    end;
    if (__isset_Param2) then begin
      if not _first29 then _sb28.Append(',');
      _first29 := FALSE;
      _sb28.Append('Param2: ');
      _sb28.Append( Self.Param2);
    end;
    _sb28.Append(')');
    Result := _sb28.ToString;
    if _first29 then {prevent warning};
  finally
    _sb28.Free;
  end;
end;

constructor TCalculatorService.TMul_resultImpl.Create;
begin
  inherited;
end;

destructor TCalculatorService.TMul_resultImpl.Destroy;
begin
  inherited;
end;

function TCalculatorService.TMul_resultImpl.GetSuccess: Integer;
begin
  Result := FSuccess;
end;

procedure TCalculatorService.TMul_resultImpl.SetSuccess( const Value: Integer);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TCalculatorService.TMul_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

procedure TCalculatorService.TMul_resultImpl.Read( const iprot: IProtocol);
var
  field_ : TThriftField;
  struc : TThriftStruct;
  tracker : IProtocolRecursionTracker;

begin
  tracker := iprot.NextRecursionLevel;
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = TType.Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = TType.I32) then begin
            Self.Success := iprot.ReadI32();
          end else begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TCalculatorService.TMul_resultImpl.Write( const oprot: IProtocol);
var
  struc : TThriftStruct;
  field_ : TThriftField;
  tracker : IProtocolRecursionTracker;
begin
  tracker := oprot.NextRecursionLevel;
  Thrift.Protocol.Init( struc, 'mul_result');
  oprot.WriteStructBegin(struc);
  Thrift.Protocol.Init( field_);
  if (__isset_Success) then begin
    field_.Name := 'Success';
    field_.Type_  := TType.I32;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Self.Success);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TCalculatorService.TMul_resultImpl.ToString: string;
var
  _sb30 : TThriftStringBuilder;
  _first31 : Boolean;
begin
  _sb30 := TThriftStringBuilder.Create('(');
  try
    _first31 := TRUE;
    if (__isset_Success) then begin
      if not _first31 then _sb30.Append(',');
      _first31 := FALSE;
      _sb30.Append('Success: ');
      _sb30.Append( Self.Success);
    end;
    _sb30.Append(')');
    Result := _sb30.ToString;
    if _first31 then {prevent warning};
  finally
    _sb30.Free;
  end;
end;

constructor TCalculatorService.TDiv_argsImpl.Create;
begin
  inherited;
end;

destructor TCalculatorService.TDiv_argsImpl.Destroy;
begin
  inherited;
end;

function TCalculatorService.TDiv_argsImpl.GetParam1: Integer;
begin
  Result := FParam1;
end;

procedure TCalculatorService.TDiv_argsImpl.SetParam1( const Value: Integer);
begin
  F__isset_Param1 := True;
  FParam1 := Value;
end;

function TCalculatorService.TDiv_argsImpl.Get__isset_Param1: Boolean;
begin
  Result := F__isset_Param1;
end;

function TCalculatorService.TDiv_argsImpl.GetParam2: Integer;
begin
  Result := FParam2;
end;

procedure TCalculatorService.TDiv_argsImpl.SetParam2( const Value: Integer);
begin
  F__isset_Param2 := True;
  FParam2 := Value;
end;

function TCalculatorService.TDiv_argsImpl.Get__isset_Param2: Boolean;
begin
  Result := F__isset_Param2;
end;

procedure TCalculatorService.TDiv_argsImpl.Read( const iprot: IProtocol);
var
  field_ : TThriftField;
  struc : TThriftStruct;
  tracker : IProtocolRecursionTracker;

begin
  tracker := iprot.NextRecursionLevel;
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = TType.Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = TType.I32) then begin
            Self.Param1 := iprot.ReadI32();
          end else begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = TType.I32) then begin
            Self.Param2 := iprot.ReadI32();
          end else begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TCalculatorService.TDiv_argsImpl.Write( const oprot: IProtocol);
var
  struc : TThriftStruct;
  field_ : TThriftField;
  tracker : IProtocolRecursionTracker;
begin
  tracker := oprot.NextRecursionLevel;
  Thrift.Protocol.Init( struc, 'div_args');
  oprot.WriteStructBegin(struc);
  Thrift.Protocol.Init( field_);
  if (__isset_Param1) then begin
    field_.Name := 'param1';
    field_.Type_  := TType.I32;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Self.Param1);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Param2) then begin
    field_.Name := 'param2';
    field_.Type_  := TType.I32;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Self.Param2);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TCalculatorService.TDiv_argsImpl.ToString: string;
var
  _sb32 : TThriftStringBuilder;
  _first33 : Boolean;
begin
  _sb32 := TThriftStringBuilder.Create('(');
  try
    _first33 := TRUE;
    if (__isset_Param1) then begin
      if not _first33 then _sb32.Append(',');
      _first33 := FALSE;
      _sb32.Append('Param1: ');
      _sb32.Append( Self.Param1);
    end;
    if (__isset_Param2) then begin
      if not _first33 then _sb32.Append(',');
      _first33 := FALSE;
      _sb32.Append('Param2: ');
      _sb32.Append( Self.Param2);
    end;
    _sb32.Append(')');
    Result := _sb32.ToString;
    if _first33 then {prevent warning};
  finally
    _sb32.Free;
  end;
end;

constructor TCalculatorService.TDiv_resultImpl.Create;
begin
  inherited;
end;

destructor TCalculatorService.TDiv_resultImpl.Destroy;
begin
  inherited;
end;

function TCalculatorService.TDiv_resultImpl.GetSuccess: Integer;
begin
  Result := FSuccess;
end;

procedure TCalculatorService.TDiv_resultImpl.SetSuccess( const Value: Integer);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TCalculatorService.TDiv_resultImpl.Get__isset_Success: Boolean;
begin
  Result := F__isset_Success;
end;

function TCalculatorService.TDiv_resultImpl.GetError: TTInvalidParameterException.ITInvalidParameterExceptionFactory;
begin
  Result := FError;
end;

procedure TCalculatorService.TDiv_resultImpl.SetError( const Value: TTInvalidParameterException.ITInvalidParameterExceptionFactory);
begin
  F__isset_Error := True;
  FError := Value;
end;

function TCalculatorService.TDiv_resultImpl.Get__isset_Error: Boolean;
begin
  Result := F__isset_Error;
end;

procedure TCalculatorService.TDiv_resultImpl.Read( const iprot: IProtocol);
var
  field_ : TThriftField;
  struc : TThriftStruct;
  tracker : IProtocolRecursionTracker;

begin
  tracker := iprot.NextRecursionLevel;
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = TType.Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = TType.I32) then begin
            Self.Success := iprot.ReadI32();
          end else begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        1: begin
          if (field_.Type_ = TType.Struct) then begin
            Self.Error := TTInvalidParameterException.TTInvalidParameterExceptionFactoryImpl.Create;
            Self.Error.Read(iprot);
          end else begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TCalculatorService.TDiv_resultImpl.Write( const oprot: IProtocol);
var
  struc : TThriftStruct;
  field_ : TThriftField;
  tracker : IProtocolRecursionTracker;
begin
  tracker := oprot.NextRecursionLevel;
  Thrift.Protocol.Init( struc, 'div_result');
  oprot.WriteStructBegin(struc);
  Thrift.Protocol.Init( field_);
  if (__isset_Success) then begin
    field_.Name := 'Success';
    field_.Type_  := TType.I32;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Self.Success);
    oprot.WriteFieldEnd();
  end;
  if (Self.Error <> nil) and __isset_Error then begin
    field_.Name := 'error';
    field_.Type_  := TType.Struct;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    Self.Error.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TCalculatorService.TDiv_resultImpl.ToString: string;
var
  _sb34 : TThriftStringBuilder;
  _first35 : Boolean;
begin
  _sb34 := TThriftStringBuilder.Create('(');
  try
    _first35 := TRUE;
    if (__isset_Success) then begin
      if not _first35 then _sb34.Append(',');
      _first35 := FALSE;
      _sb34.Append('Success: ');
      _sb34.Append( Self.Success);
    end;
    if (Self.Error <> nil) and __isset_Error then begin
      if not _first35 then _sb34.Append(',');
      _first35 := FALSE;
      _sb34.Append('Error: ');
      if (Self.Error = nil) then _sb34.Append('<null>') else _sb34.Append( Self.Error.ToString());
    end;
    _sb34.Append(')');
    Result := _sb34.ToString;
    if _first35 then {prevent warning};
  finally
    _sb34.Free;
  end;
end;


initialization

finalization


end.
